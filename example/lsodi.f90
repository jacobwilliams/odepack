!>
!! Demonstration program for the DLSODI package.
!! This is the version of 14 June 2001.
!!
!! This version is in double precision.
!!
!! this program solves a semi-discretized form of the Burgers equation,
!!```text
!!     u  = -(u*u/2)  + eta * u
!!      t           x          xx
!!
!! for a = -1 .le. x .le. 1 = b, t .ge. 0.
!! Here eta = 0.05.
!! Boundary conditions: u(-1,t) = u(1,t) = 0.
!! Initial profile: square wave
!!     u(0,x) = 0    for 1/2 .lt. abs(x) .le. 1
!!     u(0,x) = 1/2  for abs(x) = 1/2
!!     u(0,x) = 1    for 0 .le. abs(x) .lt. 1/2
!!```
!! An ODE system is generated by a simplified Galerkin treatment
!! of the spatial variable x.
!!
!!### Reference:
!! R. C. Y. Chin, G. W. Hedstrom, and K. E. Karlsson,
!! A Simplified Galerkin Method for Hyperbolic Equations,
!! Math. Comp., vol. 33, no. 146 (April 1979), pp. 647-658.
!!
!! The problem is run with the DLSODI package with a 10-point mesh
!! and a 100-point mesh.  In each case, it is run with two tolerances
!! and for various appropriate values of the method flag mf.
!! Output is on unit lout, set to 6 in a data statement below.
!-----------------------------------------------------------------------
program lsodi
use M_odepack
implicit none
integer,parameter :: dp=kind(0.0d0)
!
real(kind=dp) :: eodsq , r4d
integer :: nm1
common /test1 / r4d , eodsq , nm1
!
real(kind=dp) , save :: a , b , eta , fourth , half , hun , one ,  &
 & tinit , tlast , zero
real(kind=dp) , dimension(2) , save :: atol , rtol
real(kind=dp) :: delta , errfac , t
integer :: i , io , istate , j , meth , mf , miter , n , n14 ,    &
 & n14m1 , n14p1 , n34 , n34m1 , n34p1 , nerr , npts , nptsm1
integer , save :: itol , liw , lout , lrw , ml , mu , nout
integer , dimension(125) :: iwork
real(kind=dp) , dimension(2002) :: rwork
real(kind=dp) , dimension(4) , save :: tout
real(kind=dp) , dimension(99) :: y , ydoti
external addabd , addafl , jacbd , jacfl , res
real(kind=dp),external :: elkup
!
! Pass problem parameters in the Common block test1.
!
! Set problem parameters and run parameters
data eta/0.05d0/ , a/ - 1.0d0/ , b/1.0d0/
data zero/0.0d0/ , fourth/0.25d0/ , half/.5d0/ , one/1.0d0/ ,     &
 & hun/100.0d0/
data tinit/0.0d0/ , tlast/0.4d0/
data tout/.10d0 , .20d0 , .30d0 , .40d0/
data ml/1/ , mu/1/ , lout/6/
data nout/4/ , lrw/2002/ , liw/125/
data itol/1/ , rtol/1.0d-3 , 1.0d-6/ , atol/1.0d-3 , 1.0d-6/
!
      iwork(1) = ml
      iwork(2) = mu
      nerr = 0
!
! Loop over two values of npts.
      do npts = 10 , 100 , 90
!
! Compute the mesh width delta and other parameters.
         delta = (b-a)/npts
         r4d = fourth/delta
         eodsq = eta/delta**2
         nptsm1 = npts - 1
         n14 = npts/4
         n34 = 3*n14
         n14m1 = n14 - 1
         n14p1 = n14m1 + 2
         n34m1 = n34 - 1
         n34p1 = n34m1 + 2
         n = nptsm1
         nm1 = n - 1
!
! Set the initial profile (for output purposes only).
!
         do i = 1 , n14m1
            y(i) = zero
         enddo
         y(n14) = half
         do i = n14p1 , n34m1
            y(i) = one
         enddo
         y(n34) = half
         do i = n34p1 , nptsm1
            y(i) = zero
         enddo
!
         if ( npts>10 ) write (lout,99001)
99001    format (///80('*')///)
         write (lout,99002)
!
99002    format (20x,' Demonstration Problem for DLSODI')
         write (lout,99003) eta , a , b , tinit , tlast , ml , mu , n
99003    format (/10x,                                                  &
                &' Simplified Galerkin Solution of Burgers Equation'//  &
               & 13x,'Diffusion coefficient is eta =',d10.2/13x,        &
                &'Uniform mesh on interval',d12.3,' to ',d12.3/13x,     &
                &'Zero boundary conditions'/13x,'Time limits: t0 = ',   &
               & d12.5,'   tlast = ',d12.5/13x,'Half-bandwidths ml = ', &
               & i2,'   mu = ',i2/13x,'System size neq = ',i3/)
         write (lout,99004) zero , (y(i),i=1,n) , zero
!
99004    format ('Initial profile:'/17(6d12.4/))
!
! The j loop is over error tolerances.
!
         do j = 1 , 2
!
! Loop over method flag loop (for demonstration).
!
            do meth = 1 , 2
               do miter = 1 , 5
                  if ( miter/=3 ) then
                     if ( miter>2 .or. npts<=10 ) then
                        if ( miter/=5 .or. npts>=100 ) then
                           mf = 10*meth + miter
!
! Set the initial profile.
!
                           do i = 1 , n14m1
                              y(i) = zero
                           enddo
                           y(n14) = half
                           do i = n14p1 , n34m1
                              y(i) = one
                           enddo
                           y(n34) = half
                           do i = n34p1 , nptsm1
                              y(i) = zero
                           enddo
!
                           t = tinit
                           istate = 0
!
                           write (lout,99005) rtol(j) , atol(j) , mf ,  &
                                & npts
!
99005                      format (///80('-')///'Run with rtol =',d12.2,&
                                  &'  atol =',d12.2,'   mf =',i3,       &
                                  &'   npts =',i4,':'//)
!
!  Output loop for each case
!
                           do io = 1 , nout
!
!         call DLSODI
                              if ( miter<=2 )                           &
                                 & call dlsodi(res,addafl,jacfl,[n],y,    &
                                 & ydoti,t,tout(io),itol,rtol(j),atol(j)&
                                 & ,1,istate,0,rwork,lrw,iwork,liw,mf)
                              if ( miter>=4 )                           &
                                 & call dlsodi(res,addabd,jacbd,[n],y,    &
                                 & ydoti,t,tout(io),itol,rtol(j),atol(j)&
                                 & ,1,istate,0,rwork,lrw,iwork,liw,mf)
                              write (lout,99006) t , rwork(11) ,        &
                                   & iwork(14) , (y(i),i=1,n)
!
99006                         format ('Output for time t = ',d12.5,     &
                                     &'   current h =',d12.5,           &
                                     &'   current order =',i2,          &
                                    & ':'/17(6d12.4/))
!
! If istate is not 2 on return, print message and loop.
                              if ( istate/=2 ) then
                                 write (lout,99007) mf , t , istate
!
99007                            format (///80('*')//20x,               &
                                   &'Final time reached for mf = ',i2,  &
                                   &' was t = ',d12.5/25x,              &
                                   &'at which istate = ',i2////80('*'))
                                 nerr = nerr + 1
                                 goto 10
                              endif
!
                           enddo
!
                           write (lout,99008) mf , iwork(11) , iwork(12)&
                                & , iwork(13) , iwork(17) , iwork(18)
!
99008                      format (//'Final statistics for mf = ',i2,   &
                                 & ':'/i4,' steps,',i5,' res,',i4,      &
                                  &' Jacobians,','   rwork size =',i6,  &
                                  &',   iwork size =',i6)
!
! Estimate final error and print result.
                           errfac = elkup(n,y,rwork(21),itol,rtol(j),   &
                                  & atol(j))
                           if ( errfac>hun ) then
                              write (lout,99009) errfac
99009                         format ('  Final output is wrong by ',    &
                                    & d8.1,                             &
                                     &'  times local error tolerance')
                              nerr = nerr + 1
                           else
                              write (lout,99010) errfac
99010                         format (                                  &
                                 &'  Final output is correct to within '&
                                & ,d8.1,'  times local error tolerance')
                           endif
                        endif
                     endif
                  endif
 10            enddo
            enddo
         enddo
      enddo
!
      write (lout,99011) nerr
99011 format (//80('*')                                                 &
             &//'Run completed.  Number of errors encountered =',i3)
!
! end of main program for the DLSODI demonstration problem.
end program lsodi

subroutine res(n,t,y,v,r,ires)
implicit none
integer,parameter :: dp=kind(0.0d0)
!
real(kind=dp) :: eodsq , r4d
integer :: nm1
common /test1 / r4d , eodsq , nm1
!
integer :: n
real(kind=dp) :: t
real(kind=dp) , dimension(n) :: y
real(kind=dp) , dimension(n) :: v
real(kind=dp) , dimension(n) :: r
integer :: ires
!
real(kind=dp) :: fact1 , fact4
real(kind=dp) , save :: four , one , six
integer :: i
!
data one/1.0d0/ , four/4.0d0/ , six/6.0d0/
!
      call gfun(n,t,y,r)
      if ( ires==-1 ) return
!
      fact1 = one/six
      fact4 = four/six
      r(1) = r(1) - (fact4*v(1)+fact1*v(2))
      do i = 2 , nm1
         r(i) = r(i) - (fact1*v(i-1)+fact4*v(i)+fact1*v(i+1))
      enddo
      r(n) = r(n) - (fact1*v(nm1)+fact4*v(n))
! end of subroutine res for the DLSODI demonstration problem.
end subroutine res

subroutine gfun(n,t,y,g)
implicit none
integer,parameter :: dp=kind(0.0d0)
!
real(kind=dp) :: eodsq , r4d
integer :: nm1
common /test1 / r4d , eodsq , nm1
!
integer :: n
real(kind=dp) :: t
real(kind=dp) , dimension(n) :: y
real(kind=dp) , dimension(n) :: g
!
integer :: i
real(kind=dp) , save :: two
!
data two/2.0d0/
!
      g(1) = -r4d*y(2)**2 + eodsq*(y(2)-two*y(1))
!
      do i = 2 , nm1
         g(i) = r4d*(y(i-1)**2-y(i+1)**2)                               &
              & + eodsq*(y(i+1)-two*y(i)+y(i-1))
      enddo
!
      g(n) = r4d*y(nm1)**2 + eodsq*(y(nm1)-two*y(n))
!
! end of subroutine gfun for the DLSODI demonstration problem.
end subroutine gfun

subroutine addabd(n,t,y,ml,mu,pa,m0)
implicit none
integer,parameter :: dp=kind(0.0d0)
!
integer :: n
real(kind=dp) :: t
real(kind=dp) , dimension(n) :: y
integer :: ml
integer :: mu
real(kind=dp) , dimension(m0,n) :: pa
integer :: m0
!
real(kind=dp) :: fact1 , fact4
real(kind=dp) , save :: four , one , six
integer :: i , mup1 , mup2
!
      data one/1.0d0/ , four/4.0d0/ , six/6.0d0/
!
! Set the pointers.
      mup1 = mu + 1
      mup2 = mu + 2
! Compute the elements of A.
      fact1 = one/six
      fact4 = four/six
! Add the matrix A to the matrix pa (banded).
      do i = 1 , n
         pa(mu,i) = pa(mu,i) + fact1
         pa(mup1,i) = pa(mup1,i) + fact4
         pa(mup2,i) = pa(mup2,i) + fact1
      enddo
! end of subroutine addabd for the DLSODI demonstration problem.
end subroutine addabd

subroutine addafl(n,t,y,ml,mu,pa,m0)
implicit none
integer,parameter :: dp=kind(0.0d0)
!
real(kind=dp) :: eodsq , r4d
integer :: nm1
common /test1 / r4d , eodsq , nm1
!
integer :: n
real(kind=dp) :: t
real(kind=dp) , dimension(n) :: y
integer :: ml
integer :: mu
real(kind=dp) , dimension(m0,n) :: pa
integer :: m0
!
real(kind=dp) :: fact1 , fact4
real(kind=dp) , save :: four , one , six
integer :: i
!
data one/1.0d0/ , four/4.0d0/ , six/6.0d0/
!
! Compute the elements of A.
      fact1 = one/six
      fact4 = four/six
!
! Add the matrix A to the matrix pa (full).
!
      do i = 2 , nm1
         pa(i,i+1) = pa(i,i+1) + fact1
         pa(i,i) = pa(i,i) + fact4
         pa(i,i-1) = pa(i,i-1) + fact1
      enddo
      pa(1,2) = pa(1,2) + fact1
      pa(1,1) = pa(1,1) + fact4
      pa(n,n) = pa(n,n) + fact4
      pa(n,nm1) = pa(n,nm1) + fact1
! end of subroutine addafl for the DLSODI demonstration problem.
end subroutine addafl

subroutine jacbd(n,t,y,s,ml,mu,pa,m0)
implicit none
integer,parameter :: dp=kind(0.0d0)
!
real(kind=dp) :: eodsq , r4d
integer :: nm1
common /test1 / r4d , eodsq , nm1
!
integer :: n
real(kind=dp) :: t
real(kind=dp) , dimension(n) :: y
real(kind=dp) , dimension(n) :: s
integer :: ml
integer :: mu
real(kind=dp) , dimension(m0,n) :: pa
integer :: m0
!
real(kind=dp) :: diag , r2d
integer :: i , mup1 , mup2
real(kind=dp) , save :: two
!
data two/2.0d0/
!
      mup1 = mu + 1
      mup2 = mu + 2
      diag = -two*eodsq
      r2d = two*r4d
!                     1   1
! Compute and store dg /dy
      pa(mup1,1) = diag
!
!                     1   2
! Compute and store dg /dy
      pa(mu,2) = -r2d*y(2) + eodsq
!
      do i = 2 , nm1
!
!                     i   i-1
! Compute and store dg /dy
         pa(mup2,i-1) = r2d*y(i-1) + eodsq
!
!                     i   i
! Compute and store dg /dy
         pa(mup1,i) = diag
!
!                     i   i+1
! Compute and store dg /dy
         pa(mu,i+1) = -r2d*y(i+1) + eodsq
      enddo
!
!                     n   n-1
! Compute and store dg /dy
      pa(mup2,nm1) = r2d*y(nm1) + eodsq
!
!                     n   n
! Compute and store dg /dy
      pa(mup1,n) = diag
!
! end of subroutine jacbd for the DLSODI demonstration problem.
end subroutine jacbd

subroutine jacfl(n,t,y,s,ml,mu,pa,m0)
implicit none
integer,parameter :: dp=kind(0.0d0)
!
real(kind=dp) :: eodsq , r4d
integer :: nm1
common /test1 / r4d , eodsq , nm1
!
integer :: n
real(kind=dp) :: t
real(kind=dp) , dimension(n) :: y
real(kind=dp) , dimension(n) :: s
integer :: ml
integer :: mu
real(kind=dp) , dimension(m0,n) :: pa
integer :: m0
!
real(kind=dp) :: diag , r2d
integer :: i
real(kind=dp) , save :: two
!
data two/2.0d0/
!
      diag = -two*eodsq
      r2d = two*r4d
!
!                     1   1
! Compute and store dg /dy
      pa(1,1) = diag
!
!                     1   2
! Compute and store dg /dy
      pa(1,2) = -r2d*y(2) + eodsq
!
      do i = 2 , nm1
!
!                     i   i-1
! Compute and store dg /dy
         pa(i,i-1) = r2d*y(i-1) + eodsq
!
!                     i   i
! Compute and store dg /dy
         pa(i,i) = diag
!
!                     i   i+1
! Compute and store dg /dy
         pa(i,i+1) = -r2d*y(i+1) + eodsq
      enddo
!
!                     n   n-1
! Compute and store dg /dy
      pa(n,nm1) = r2d*y(nm1) + eodsq
!
!                     n   n
! Compute and store dg /dy
      pa(n,n) = diag
!
! end of subroutine jacfl for the DLSODI demonstration problem.
end subroutine jacfl

function elkup(n,y,ewt,itol,rtol,atol)
use M_odepack
implicit none
integer,parameter :: dp=kind(0.0d0)
real(kind=dp) :: elkup
!
integer :: n
real(kind=dp) , dimension(n) :: y
real(kind=dp) , dimension(n) :: ewt
integer :: itol
real(kind=dp) :: rtol(*)
real(kind=dp) :: atol(*)
!
integer :: i
real(kind=dp) , dimension(9) , save  :: y9
real(kind=dp) , dimension(99)        :: y99
real(kind=dp) , dimension(16) , save :: y99a , y99b , y99c , y99d ,&
 & y99e , y99f
real(kind=dp) , dimension(3) , save  :: y99g
!
equivalence (y99a(1),y99(1))
equivalence (y99b(1),y99(17))
equivalence (y99c(1),y99(33))
equivalence (y99d(1),y99(49))
equivalence (y99e(1),y99(65))
equivalence (y99f(1),y99(81))
equivalence (y99g(1),y99(97))
data y9/ &
 & 1.07001457d-01 , 2.77432492d-01 , 5.02444616d-01 ,     &
 & 7.21037157d-01 , 9.01670441d-01 , 8.88832048d-01 ,     &
 & 4.96572850d-01 , 9.46924362d-02 , -6.90855199d-03/
data y99a/ &
 & 2.05114384d-03 , 4.19527452d-03 , 6.52533872d-03 ,     &
 & 9.13412751d-03 , 1.21140191d-02 , 1.55565301d-02 ,     &
 & 1.95516488d-02 , 2.41869487d-02 , 2.95465081d-02 ,     &
 & 3.57096839d-02 , 4.27498067d-02 , 5.07328729d-02 ,     &
 & 5.97163151d-02 , 6.97479236d-02 , 8.08649804d-02 ,     &
 & 9.30936515d-02/
data y99b/ &
 & 1.06448659d-01 , 1.20933239d-01 , 1.36539367d-01 ,     &
 & 1.53248227d-01 , 1.71030869d-01 , 1.89849031d-01 ,     &
 & 2.09656044d-01 , 2.30397804d-01 , 2.52013749d-01 ,     &
 & 2.74437805d-01 , 2.97599285d-01 , 3.21423708d-01 ,     &
 & 3.45833531d-01 , 3.70748792d-01 , 3.96087655d-01 ,     &
 & 4.21766871d-01/
data y99c/ &
 & 4.47702161d-01 , 4.73808532d-01 , 5.00000546d-01 ,     &
 & 5.26192549d-01 , 5.52298887d-01 , 5.78234121d-01 ,     &
 & 6.03913258d-01 , 6.29252015d-01 , 6.54167141d-01 ,     &
 & 6.78576790d-01 , 7.02400987d-01 , 7.25562165d-01 ,     &
 & 7.47985803d-01 , 7.69601151d-01 , 7.90342031d-01 ,     &
 & 8.10147715d-01/
data y99d/ &
 & 8.28963844d-01 , 8.46743353d-01 , 8.63447369d-01 ,     &
 & 8.79046021d-01 , 8.93519106d-01 , 9.06856541d-01 ,     &
 & 9.19058529d-01 , 9.30135374d-01 , 9.40106872d-01 ,     &
 & 9.49001208d-01 , 9.56853318d-01 , 9.63702661d-01 ,     &
 & 9.69590361d-01 , 9.74555682d-01 , 9.78631814d-01 ,     &
 & 9.81840924d-01/
data y99e/ &
 & 9.84188430d-01 , 9.85656465d-01 , 9.86196496d-01 ,     &
 & 9.85721098d-01 , 9.84094964d-01 , 9.81125395d-01 ,     &
 & 9.76552747d-01 , 9.70041743d-01 , 9.61175143d-01 ,     &
 & 9.49452051d-01 , 9.34294085d-01 , 9.15063568d-01 ,     &
 & 8.91098383d-01 , 8.61767660d-01 , 8.26550038d-01 ,     &
 & 7.85131249d-01/
data y99f/ &
 & 7.37510044d-01 , 6.84092540d-01 , 6.25748369d-01 ,     &
 & 5.63802368d-01 , 4.99946558d-01 , 4.36077986d-01 ,     &
 & 3.74091566d-01 , 3.15672765d-01 , 2.62134958d-01 ,     &
 & 2.14330497d-01 , 1.72640946d-01 , 1.37031155d-01 ,     &
 & 1.07140815d-01 , 8.23867920d-02 , 6.20562432d-02 ,     &
 & 4.53794321d-02/
data y99g/ &
 & 3.15789227d-02 , 1.98968820d-02 , 9.60472135d-03/
!
      if ( n==99 ) then
!
! Compute local error tolerance using correct y (n = 99).
!
         call dewset(n,itol,rtol,atol,y99,ewt)
!
! Invert ewt and replace y by the error, y - ytrue.
!
         do i = 1 , 99
            ewt(i) = 1.0d0/ewt(i)
            y(i) = y(i) - y99(i)
         enddo
      else
!
! Compute local error tolerance using correct y (n = 9).
!
         call dewset(n,itol,rtol,atol,y9,ewt)
!
! Invert ewt and replace y by the error, y - ytrue.
!
         do i = 1 , 9
            ewt(i) = 1.0d0/ewt(i)
            y(i) = y(i) - y9(i)
         enddo
      endif
!
! Find weighted norm of the error and return.
!
      elkup = dvnorm(n,y,ewt)
! end of function elkup for the DLSODI demonstration program.
end function elkup
